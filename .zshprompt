#!/bin/zsh
# dotfiles: a collection of configuration files
# Copyright (C) 2013, 2014 Cyphar

# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:

# 1. The above copyright notice and this permission notice shall be included in
#    all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Enable prompt substitution and colours.
autoload -U colors; colors
setopt prompt_subst

# Set up precmd hook to set up prompt.
function precmd() {
	local user_prompt
	local path_prompt
	local ret_prompt

	# Save old exit code first.
	local __exit_code="$?"

	# User information.
	if [[ "${EUID}" == "0" ]]; then
		user_prompt="%{$fg_bold[red]%}%M%{$reset_color%}"
	else
		user_prompt="%{$fg_bold[green]%}%n%{$reset_color%}%{$fg[green]%}@%M%{$reset_color%}"
	fi

	# Git branch and ref information.
	function __git_info() {
		if (git status &>/dev/null); then
			local branch="$(git branch --list | grep "^\*" | cut -d' ' -f2)"
			local info

			# Figure out if in detached state.
			if (grep "^ref: " ".git/HEAD" &>/dev/null); then
				info="%{$fg_bold[magenta]%}${branch}%{$reset_color%}"
			else
				info="%{$fg_bold[red]%}{detached}%{$reset_color%}"
			fi

			local ref="$(git rev-parse --short --verify HEAD)"
			echo " git:(${info}:%{$fg[magenta]%}${ref}%{$reset_color%})"
		fi
	}

	# Mercurial branch information.
	function __hg_info() {
		if (hg status &>/dev/null); then
			local branch="$(hg branch)"
			echo " hg:(%{$fg_bold[magenta]%}${branch}%{$reset_color%})"
		fi
	}

	function __nice_path() {
		local __path
		__path="$(pwd)"

		if [[ "${__path}" == "${HOME}" ]]; then
			__path="~"
		else
			__path="$(basename ${__path})"
		fi

		echo "${__path}"
	}

	# Path information.
	path_prompt="%{$fg_bold[blue]%}$(__nice_path)%{$reset_color%}$(__git_info)$(__hg_info)"

	# Return prompt based on exit code of last command.
	function __ret_prompt() {
		__prompt="%#"

		if [[ "${__exit_code}" != "0" ]]; then
			__prompt="%{$fg_bold[red]%}${__prompt}%{$reset_color%}"
		fi

		echo "${__prompt} "
	}
	ret_prompt="$(__ret_prompt)"

	# Get loadavg for last minute.
	function __loadavg() {
		[[ -f "/proc/loadavg" ]] && echo "$(cat /proc/loadavg 2>/dev/null | cut -d' ' -f1)"
	}

	# Get number of processes, if we can.
	function __nproc() {
		echo "$(nproc 2>/dev/null || echo '?')"
	}

	# Actually set up prompts.
	export PROMPT="$user_prompt %{$fg[cyan]%}::%{$reset_color%} $path_prompt $ret_prompt"
	export RPROMPT="[$(uname -o) $(__loadavg)($(__nproc))]"

	# Set up secondary prompts.
	export PS1="${PROMPT}"
	export PS2="%_> "
	export PS3="?#> "
	export PS4="+> "
}
